#ifndef WDR_COMPRESSOR_HPP
#define WDR_COMPRESSOR_HPP

/**
 * @file wdr_compressor.hpp
 * @brief Wavelet Difference Reduction (WDR) compressor implementation
 *
 * This implementation is based on the Wavelet Difference Reduction algorithm
 * for embedded image compression. The WDR algorithm combines:
 * - Discrete Wavelet Transform (DWT) for spatial-frequency decomposition
 * - Differential coding and binary reduction for efficient index encoding
 * - Ordered bit-plane transmission for progressive compression
 * - Adaptive arithmetic coding for final lossless compression
 *
 * The adaptive arithmetic coding stage uses the algorithm from
 * Witten, I.H., Neal, R.M., & Cleary, J.G. (1987). "Arithmetic coding
 * for data compression." Communications of the ACM, 30(6), 520-540.
 *
 * @see WDR algorithm paper for the original WDR algorithm
 * @see Witten, Neal, & Cleary (1987) for the arithmetic coding algorithm
 */

#include "adaptive_model.hpp"
#include "arithmetic_coder.hpp"
#include "bit_stream.hpp"
#include "wdr_file_format.hpp"
#include <cmath>
#include <cstdint>
#include <fstream>
#include <list>
#include <string>
#include <utility>
#include <vector>

// Forward declaration for friend tests
namespace testing {
class Test;
}

/**
 * @brief WDR Compressor
 * * Implements the Wavelet Difference Reduction (WDR) compression algorithm.
 * * The algorithm consists of three main stages:
 * 1. Sorting Pass: Find significant coefficients and generate symbols for
 * their positions and signs.
 * 2. Refinement Pass: Refine existing significant coefficients by generating
 * one bit-symbol per coefficient per pass.
 * 3. Adaptive Arithmetic Coding: Final compression stage that encodes the
 * single, interleaved symbol stream.
 * * The compressor maintains three lists:
 * - ICS (Insignificant Coefficient Set): Coefficients not yet significant
 * - SCS (Significant Coefficient Set): Coefficients that are significant
 * - TPS (Temporary Pass Set): Coefficients found significant in current pass
 * * @note This implementation uses separate adaptive models for the
 * **sorting pass** (index bits and signs) and the **refinement pass**
 * to maintain compression efficiency.
 * * @see WDR algorithm paper for detailed algorithm description
 * @see Witten, Neal, & Cleary (1987) for arithmetic coding details
 */

class WDRCompressor {
  // Friend test classes
  friend class WDRCompressorTest;
  friend class WDRCompressorPassesTest;

public:
  /**
   * Constructor.
   *
   * @param num_passes Number of bit-plane passes (default: 16)
   */
  explicit WDRCompressor(int num_passes = 16);

  /**
   * Compress coefficients to a .wdr file.
   *
   * @param coeffs Input coefficients (1D array)
   * @param output_file Output file path
   */
  void compress(const std::vector<double> &coeffs,
                const std::string &output_file);

  /**
   * Decompress coefficients from a .wdr file.
   *
   * @param input_file Input file path
   * @return Decompressed coefficients (1D array)
   */
  std::vector<double> decompress(const std::string &input_file);

  // Test-friendly public accessors for unit testing
  // These methods are public to allow comprehensive unit testing
  // In production, they could be made private with friend test classes

  /**
   * Calculate the initial threshold T (public for testing).
   */
  double calculate_initial_T(const std::vector<double> &coeffs);

  /**
   * Apply differential coding (public for testing).
   */
  std::vector<int> differential_encode(const std::vector<int> &indices);

  /**
   * Apply inverse differential coding (public for testing).
   */
  std::vector<int> differential_decode(const std::vector<int> &diff_indices);

private:
  int num_passes_;
  double initial_T_;

  /**
   * @brief Defines the context of a symbol, mapping to a specific adaptive
   model (exploit redundancy in position stream and refinement stream).
   *
   * This is an in-memory-only "tag" for the encoder. The decoder knows the
   * context based on its state-machine logic.
   */
  enum class SymbolContext : uint8_t {
    /**
     * @brief For the sorting pass.
     * The alphabet for this context includes:
     * 0 = index bit 0
     * 1 = index bit 1
     * 2 = positive sign (End-of-Message symbol)
     * 3 = negative sign (End-of-Message symbol)
     * 4 = zero positive (End-of-Message symbol)
     * 5 = zero negative (End-of-Message symbol) See compress() on
     * wdr_compressor.cpp for details
     */
    SORTING_PASS,

    /**
     * @brief For the refinement pass.
     * The alphabet for this context includes:
     * 0 = refinement bit 0
     * 1 = refinement bit 1
     */
    REFINEMENT_PASS
  };

  /**
   * @brief Represents a single symbol generated by the WDR passes.
   *
   * This struct is used to create an in-memory list (the "script") of all
   * symbols before the final arithmetic encoding step.
   */
  struct WDRSymbol {
    SymbolContext context;
    uint8_t symbol; // The symbol to be encoded

    WDRSymbol(SymbolContext c, uint8_t s) : context(c), symbol(s) {}
  };

  // Coefficient sets for encoding/decoding
  const std::vector<double> *original_coeffs_ptr_ =
      nullptr; // Pointer to original coefficients (for fast access)
  std::list<size_t> ICS_indices_list_; // Double linked list of indices in the
                                       // ICS (for fast removal and iteration)
  std::vector<std::pair<double, double>>
      SCS_;                 // Significant Coefficient Set: (value, center)
  std::vector<double> TPS_; // Temporary Pass Set

  // For decoding: track which positions in the original array have been decoded
  std::vector<size_t>
      scs_to_array_pos_; // Maps SCS index to array position (for decoding)
  std::vector<int>
      scs_signs_; // Maps SCS index to sign (1 for positive, 0 for negative)
  std::vector<double> reconstructed_array_; // Reconstructed coefficient array

  /**
   * Sorting pass (encoding).
   *
   * Finds significant coefficients and generates symbols for their positions
   * and signs. Appends symbols to the master symbol_stream.
   *
   * @param T Current threshold
   * @param symbol_stream The master list of symbols to append to
   */
  void sorting_pass_encode(double T, std::vector<WDRSymbol> &symbol_stream);

  /**
   * Refinement pass (encoding).
   *
   * Generates refinement bit symbols for existing significant coefficients.
   * Appends symbols to the master symbol_stream.
   *
   * @param T Current threshold
   * @param symbol_stream The master list of symbols to append to
   */
  void refinement_pass_encode(double T, std::vector<WDRSymbol> &symbol_stream);

  /**
   * Sorting pass (decoding).
   *
   * Decodes positions and signs from the arithmetic coder using a
   * *single* sorting model, reconstructing significant coefficients.
   *
   * @param T Current threshold
   * @param coder Arithmetic coder
   * @param sorting_model Adaptive model for sorting pass symbols (index bits +
   * signs)
   * @param decoded_positions Output: positions in the original array that were
   * decoded
   * @param decoded_signs Output: signs for decoded coefficients
   * @param ics_to_array_map Mapping from ICS index to array position (double linked list)
   */
  void sorting_pass_decode(double T, ArithmeticCoder &coder,
                           AdaptiveModel &sorting_model,
                           std::vector<size_t> &decoded_positions,
                           std::vector<int> &decoded_signs,
                           std::list<size_t> &ics_to_array_map);

  /**
   * Refinement pass (decoding).
   *
   * Decodes refinement bits and updates coefficients.
   * (Signature was already correct)
   *
   * @param T Current threshold
   * @param coder Arithmetic coder
   * @param refinement_model Adaptive model for refinement bits
   */
  void refinement_pass_decode(double T, ArithmeticCoder &coder,
                              AdaptiveModel &refinement_model);

  /**
   * @brief Performs the final arithmetic encoding step (Encoder's state
   * machine).
   *
   * Iterates over the symbol list for the current pass and encodes each symbol
   * using the GLOBAL adaptive models for the sorting and refinement passes.
   * This keeps memory usage low and allows for efficient encoding.
   *
   * @param symbol_stream_for_pass The ordered list of symbols for the current
   * pass.
   * @param coder The arithmetic coder.
   * @param sorting_model The GLOBAL adaptive model for the sorting pass.
   * @param refinement_model The GLOBAL adaptive model for the refinement pass.
   */
  void
  arithmetic_encode_stream(const std::vector<WDRSymbol> &symbol_stream_for_pass,
                           ArithmeticCoder &coder, AdaptiveModel &sorting_model,
                           AdaptiveModel &refinement_model);

  /**
   * @brief Helper to write a binary-reduced value to the symbol stream.
   *
   * Encapsulates the logic of outputting index bits (0, 1) and
   * the sign/EOM symbol (2, 3).
   *
   * @param symbol_stream The master symbol list.
   * @param value The (differential coded) index to reduce.
   * @param sign The sign of the coefficient (true=positive, false=negative).
   */
  void write_binary_reduced(std::vector<WDRSymbol> &symbol_stream, int value,
                            bool sign);

  /**
   * @brief Helper to read one binary-expanded value during decode.
   *
   * Reads symbols (0, 1) from the coder until an EOM symbol (2, 3)
   * is found, reconstructing the index.
   *
   * @param coder The arithmetic decoder.
   * @param sorting_model The adaptive model for the sorting pass.
   * @param sign_out Output parameter for the decoded sign (true=positive).
   * @return The reconstructed (differential coded) index.
   */
  int read_binary_expanded(ArithmeticCoder &coder, AdaptiveModel &sorting_model,
                           bool &sign_out);

  /**
   * Write file header.
   *
   * @param stream Output file stream
   * @param initial_T Initial threshold
   * @param num_coeffs Number of coefficients
   * @param data_size Size of compressed data in bytes
   */
  void write_header(std::ofstream &stream, double initial_T,
                    uint64_t num_coeffs, uint64_t data_size);

  /**
   * Read file header.
   *
   * @param stream Input file stream
   * @param initial_T Output: initial threshold
   * @param num_passes Output: number of passes
   * @param num_coeffs Output: number of coefficients
   * @param data_size Output: size of compressed data
   */
  void read_header(std::ifstream &stream, double &initial_T,
                   uint32_t &num_passes, uint64_t &num_coeffs,
                   uint64_t &data_size);
};

#endif // WDR_COMPRESSOR_HPP
